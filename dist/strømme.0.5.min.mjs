export default class Str√∏mme{constructor(data={}){this._data=data;this._DOMParser=new DOMParser()}
template(stringLiteral){let templateString=stringLiteral.search(/(<template>)?|(<\/template>)?/gim)!=-1?`<template> ${stringLiteral} </template>`:stringLiteral;return{compileToMixin:this._compile.bind(this,templateString),create:this._create.bind(this,templateString),}}
_create(templateString,query,data={},options){let compData=Object.assign(data,this._data);compData.query=Object.fromEntries(query.entries())||null;let parse=templateString;parse=parse.replace(/\/\*[\S\s]+?\*\//gim,'');const REGMIX=/{\s?#mixin (?<mixinName>[^}]+?)\s?}/gim;parse=parse.replace(REGMIX,(r,mixin)=>r.replace(r,compData.mixins[mixin].compileToMixin));const REGVAR=/{\s?(?<variable>[^-#}/\s ]+)\s?}/gim;parse=parse.replace(REGVAR,(r,varName)=>varName.replace(varName,this._findRef(varName,compData)));const REGIFELSE=/{\s?#if (?<condition>[^}]*?)\s?}(?<action>[\s\S]+?){\/\s?if\s?}|(?<negCon>{\s?#else\s?})(?<negAction>[^{]*)?({\s?\/if\s?})?/gim;parse=parse.replace(REGIFELSE,(r,condition,action,negCon,negAct)=>this._handleIfElse(condition,action,negCon,negAct,compData));const REGFOREACH=/{\s?#forEach (?<prop>\S*) in (?<array>\S*)\s?}(?<action>[\S\s]*?){\s?\/forEach\s?}/gim;parse=parse.replace(REGFOREACH,(r,prop,array,action)=>action.replace(action,this._handleExpression(prop,array,action,compData)));const REGFOROF=/{\s?#forOf (?<prop>\S*) in (?<object>\S*)\s?}(?<action>[\S\s]*?){\s?\/forOf\s?}/gim;parse=parse.replace(REGFOROF,(r,prop,object,action)=>action.replace(action,this._handleExpression(prop,object,action,compData)));parse=options.stripWhitespace?parse.replace(/\s/gim,''):parse;return parse}
render(parsedTemplate){return this._parser.parseFromString(parsedTemplate,'text/html').querySelector('template')}
_compile(templateString){return templateString.replace(/<template>|<\/template>/gim,'')}
_handleExpression(prop,source,action,data){source=this._findRef(source,data);let dataSource=typeof source=='array'?source:Object.values(source);const REGProp=new RegExp(`{-\\s?(?<var>${prop}[.]?[\\S]*)\\s?-}`,'gmi');return dataSource.map((elem,i)=>action.replace(REGProp,(r,group)=>group.replace(group,(r)=>r.includes('.')?this._findRef(r.split(/\./i)[1],elem):elem))).join('')}
_handleIfElse(condition,action,negation,alternative,data){return this._parseAndCheck(condition,data)?action:alternative}
_parseAndCheck(conditionString,context){const CHECKREG=/(?<negation>!)?(?<condition>[^!= ]+)\s?((?<operator>[!=]{2})\s?(?<eval>\S*))?/gim;let group=[...conditionString.matchAll(CHECKREG)][0].groups;let test={objevt:context[group.condition],value:group.eval};if(test.value==undefined&&group.operator==undefined&&group.negation!='!'){test.for=!0}else if(test.value==undefined&&group.operator==undefined&&group.negation=='!'){test.for=!1}else if(test.value!=undefined&&group.operator!=undefined){if((group.negation=='!'&&group.operator=='==')||(group.negation!='!'&&group.operator=='!=')){test.for=!1}else if((group.negation!='!'&&group.operator=='==')||(group.negation=='!'&&group.operator=='!=')){test.for=!0}}
const checkFor=(testCase)=>{if(testCase.object&&testCase.value==undefined){if(testCase.for==!0){return!0}else{return!1}}else if(testCase.object==testCase.value){if(testCase.for==!0){return!0}else{return!1}}else if(testCase.object!=testCase.value){if(testCase.for==!1){return!0}else{return!1}}};return checkFor(test)}
_findRef(string,obj){return string.includes('.')?string.split('.').reduce((o,i)=>o[i],obj):obj[string]}}