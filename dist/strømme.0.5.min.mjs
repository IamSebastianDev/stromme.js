export default class Str√∏mme{constructor(data={}){this._data=data;this._DOMParser=new DOMParser()}
template(stringLiteral){let templateString=stringLiteral.search(/(<template>)?|(<\/template>)?/gim)!=-1?`<template> ${stringLiteral} </template>`:stringLiteral;return{compileToMixin:this._compile.bind(this,templateString),create:this._create.bind(this,templateString),}}
_create(templateString,query=new URLSearchParams(),data={},options={}){let compData=Object.assign(data,this._data);compData.query=Object.fromEntries(query.entries())||null;let parse=templateString;parse=parse.replace(/\/\*[\S\s]+?\*\//gim,'');const REGMIX=/{\s?#mixin (?<mixinName>[^}]+?)\s?}/gim;parse=parse.replace(REGMIX,(r,mixin)=>r.replace(r,compData.mixins[mixin].compileToMixin));const REGVAR=/{\s?(?<variable>[^-#}/\s ]+)\s?}/gim;parse=parse.replace(REGVAR,(r,varName)=>varName.replace(varName,this._findRef(varName,compData)));const REGIFELSE=/{\s?#if (?<condition>[^}]*?)\s?}(?<action>[\s\S]+?){\/\s?if\s?}|(?<negCon>{\s?#else\s?})(?<negAction>[^{]*)?({\s?\/if\s?})?/gim;parse=parse.replace(REGIFELSE,(r,condition,action,negCon,negAct)=>this._handleIfElse(condition,action,negCon,negAct,compData));const REGFOREACH=/{\s?#forEach (?<prop>\S*) in (?<array>\S*)\s?}(?<action>[\S\s]*?){\s?\/forEach\s?}/gim;parse=parse.replace(REGFOREACH,(r,prop,array,action)=>action.replace(action,this._handleExpression(prop,array,action,compData)));const REGARRAY=/{\s?#arr (?<array>[\S]*?) (?<itt>[^=0-9]*?)=(?<init>[^=<>]*?)(?<assign><|>|<=|>=){1,2}(?<target>[^=<>]*?) (?<method>[^\s}]*?)\s?}(?<action>[\s\S]*?){\/\s?arr\s?}/gim;parse=parse.replace(REGARRAY,(r,array,itt,init,assign,target,method,action)=>action.replace(action,this._handleIteration(array,{itt,init,assign,target},method,action,compData)));parse=options.stripWhitespace?parse.replace(/\s/gim,''):parse;return parse}
render(parsedTemplate){return this._parser.parseFromString(parsedTemplate,'text/html').querySelector('template')}
_compile(templateString){return templateString.replace(/<template>|<\/template>/gim,'')}
_handleExpression(prop,source,action,data){source=this._findRef(source,data);let dataSource=typeof source=='array'?source:Object.values(source);const REGProp=new RegExp(`{-\\s?(?<var>${prop}[.]?[\\S]*)\\s?-}`,'gmi');return dataSource.map((elem,i)=>action.replace(REGProp,(r,group)=>group.replace(group,(r)=>r.includes('.')?this._findRef(r.split(/\./i)[1],elem):elem))).join('')}
_handleIfElse(condition,action,negation,alternative,data){return this._parseAndCheck(condition,data)?action:alternative}
_handleIteration(array,exp,method,action,data){let srcArr=this._findRef(array,data);let itterator=exp.init=='length'?srcArr.length:parseFloat(exp.init);let target=exp.target=='length'?srcArr.length:parseFloat(exp.target);const checkResult=()=>{switch(exp.assign){case '<':return itterator<target;break;case '>':return itterator>target;break;case '>=':return itterator>=target;break;case '<=':return itterator<=target;default:break}};const manipulateItt=(method)=>{const expression=method.replace(exp.itt,'');let operation=expression.match(/(\+\+|\-\-|\*|\/|\+|\-){1,2}\s?|\s?([0-9]?)?/gim);console.log(operation[1]);switch(operation[0]){case '++':itterator++;break;case '--':itterator--;break;case '+':itterator+=parseFloat(operation[1]);break;case '-':itterator-=parseFloat(operation[1]);break;case '*':itterator*=parseFloat(operation[1]);console.log(itterator);break;case '/':itterator/=parseFloat(operation[1]);break;default:break}};const REGProp=new RegExp(`{-\\s?\\S*?\\[${exp.itt}\\]\\s?-}`,'gmi');let propString=[];while(checkResult()){propString.push(action.replace(REGProp,srcArr[itterator]));manipulateItt(method);if(itterator>10000||itterator<-10000){break}}
return propString.join('')}
_parseAndCheck(conditionString,context){const CHECKREG=/(?<negation>!)?(?<condition>[^!= ]+)\s?((?<operator>[!=]{2})\s?(?<eval>\S*))?/gim;let group=[...conditionString.matchAll(CHECKREG)][0].groups;let test={object:context[group.condition],value:group.eval};if(test.value==undefined&&group.operator==undefined&&group.negation!='!'){test.for=!0}else if(test.value==undefined&&group.operator==undefined&&group.negation=='!'){test.for=!1}else if(test.value!=undefined&&group.operator!=undefined){if((group.negation=='!'&&group.operator=='==')||(group.negation!='!'&&group.operator=='!=')){test.for=!1}else if((group.negation!='!'&&group.operator=='==')||(group.negation=='!'&&group.operator=='!=')){test.for=!0}}
const checkFor=(testCase)=>{if(testCase.object&&testCase.value==undefined){return testCase.for?!0:!1}else if(testCase.object==testCase.value){return testCase.for?!0:!1}else if(testCase.object!=testCase.value){return!testCase.for?!0:!1}};return checkFor(test)}
_findRef(string,obj){return string.includes('.')?string.split('.').reduce((o,i)=>o[i],obj):obj[string]}}