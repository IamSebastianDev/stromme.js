export default class Str√∏mme{constructor(a={}){this._data=a}template(a){let b=-1==a.search(/(<template>)?|(<\/template>)?/gim)?a:`<template> ${a} </template>`;return{compileToMixin:this._compile.bind(this,b),create:this._create.bind(this,b)}}_create(a,b=new URLSearchParams,c={},d={}){let e=Object.assign(c,this._data);e.query=Object.fromEntries(b.entries())||null;let f=a;f=f.replace(/\/\*[\S\s]+?\*\//gim,"");f=f.replace(/{\s?#mixin (?<mixinName>[^}]+?)\s?}/gim,(a,c)=>a.replace(a,e.mixins[c].compileToMixin(b)));f=f.replace(/{\s?(?<variable>[^-#}/\s ]+)\s?}/gim,(a,b)=>b.replace(b,this._findRef(b,e)));f=f.replace(/{\s?#if (?<condition>[^}]*?)\s?}(?<action>[\s\S]+?){\/\s?if\s?}|(?<negCon>{\s?#else\s?})(?<negAction>[^{]*)?({\s?\/if\s?})?/gim,(a,b,c,d,f)=>this._handleIfElse(b,c,d,f,e));f=f.replace(/{\s?#forEach (?<prop>\S*) in (?<array>\S*)\s?}(?<action>[\S\s]*?){\s?\/forEach\s?}/gim,(a,b,c,d)=>d.replace(d,this._handleExpression(b,c,d,e)));return f=f.replace(/{\s?#arr (?<array>[\S]*?) (?<itt>[^=0-9]*?)=(?<init>[^=<>]*?)(?<assign><|>|<=|>=){1,2}(?<target>[^=<>]*?) (?<method>[^\s}]*?)\s?}(?<action>[\s\S]*?){\/\s?arr\s?}/gim,(a,b,c,d,f,g,h,i)=>i.replace(i,this._handleIteration(b,{itt:c,init:d,assign:f,target:g},h,i,e))),f=d.stripWhitespace?f.replace(/\s/gim,""):f,f}static render(a){return new DOMParser().parseFromString(a,"text/html").querySelector("template")}_compile(a,b){let c=this._create(a,b);return c.replace(/<template>|<\/template>/gim,"")}_handleExpression(a,b,c,d){b=this._findRef(b,d);let e=Array.isArray(b)?b:Object.values(b);const f=new RegExp(`{-\\s?(?<var>${a}[.]?[\\S]*)\\s?-}`,"gmi");return e.map(a=>c.replace(f,(b,c)=>c.replace(c,b=>b.includes(".")?this._findRef(b.split(/\./i)[1],a):a))).join("")}_handleIfElse(a,b,c,d,e){return this._parseAndCheck(a,e)?b:d}_handleIteration(a,b,c,d,e){let f=this._findRef(a,e),g="length"==b.init?f.length:parseFloat(b.init),h="length"==b.target?f.length:parseFloat(b.target);const i=()=>{switch(b.assign){case"<":return g<h;case">":return g>h;case">=":return g>=h;case"<=":return g<=h;default:}},j=a=>{const c=a.replace(b.itt,"");let d=c.match(/(\+\+|\-\-|\*|\/|\+|\-){1,2}\s?|\s?([0-9]?)?/gim);switch(d[0]){case"++":g++;break;case"--":g--;break;case"+":g+=parseFloat(d[1]);break;case"-":g-=parseFloat(d[1]);break;case"*":g*=parseFloat(d[1]);break;case"/":g/=parseFloat(d[1]);break;default:}},k=new RegExp(`{-\\s?\\S*?\\[${b.itt}\\]\\s?-}`,"gmi");let l=[];for(;i()&&(l.push(d.replace(k,f[g])),j(c),!(1e4<g||-1e4>g)););return l.join("")}_parseAndCheck(a,b){let c=[...a.matchAll(/(?<negation>!)?(?<condition>[^!= ]+)\s?((?<operator>[!=]{2})\s?(?<eval>\S*))?/gim)][0].groups,d={object:b[c.condition],value:c.eval};d.value==null&&c.operator==null&&"!"!=c.negation?d.for=!0:d.value==null&&c.operator==null&&"!"==c.negation?d.for=!1:d.value!=null&&c.operator!=null&&("!"==c.negation&&"=="==c.operator||"!"!=c.negation&&"!="==c.operator?d.for=!1:("!"!=c.negation&&"=="==c.operator||"!"==c.negation&&"!="==c.operator)&&(d.for=!0));return(a=>{if(a.object&&a.value==null)return!!a.for;return a.object==a.value?!!a.for:a.object==a.value?void 0:!a.for})(d)}_findRef(a,b){return a.includes(".")?a.split(".").reduce((a,b)=>a[b],b):b[a]}}